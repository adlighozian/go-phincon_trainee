
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">inventory/config/config.go (0.0%)</option>
				
				<option value="file1">inventory/controller/inventoryHttp_impl.go (12.5%)</option>
				
				<option value="file2">inventory/db/inventoryDb.go (0.0%)</option>
				
				<option value="file3">inventory/helper/bcrypt.go (0.0%)</option>
				
				<option value="file4">inventory/helper/helper.go (0.0%)</option>
				
				<option value="file5">inventory/helper/middleware/auth.go (0.0%)</option>
				
				<option value="file6">inventory/helper/middleware/failerror.go (50.0%)</option>
				
				<option value="file7">inventory/helper/middleware/logger.go (0.0%)</option>
				
				<option value="file8">inventory/helper/randomizer.go (0.0%)</option>
				
				<option value="file9">inventory/main.go (0.0%)</option>
				
				<option value="file10">inventory/mocks/inventory_controller.go (0.0%)</option>
				
				<option value="file11">inventory/mocks/product_controller.go (100.0%)</option>
				
				<option value="file12">inventory/mocks/product_service.go (100.0%)</option>
				
				<option value="file13">inventory/mocks/purchase_controller.go (11.1%)</option>
				
				<option value="file14">inventory/mocks/purchase_publisher.go (100.0%)</option>
				
				<option value="file15">inventory/mocks/purchase_service.go (100.0%)</option>
				
				<option value="file16">inventory/mocks/random.go (100.0%)</option>
				
				<option value="file17">inventory/mocks/sales_controller.go (11.1%)</option>
				
				<option value="file18">inventory/mocks/sales_publisher.go (100.0%)</option>
				
				<option value="file19">inventory/mocks/sales_service.go (100.0%)</option>
				
				<option value="file20">inventory/publisher/purchase.go (0.0%)</option>
				
				<option value="file21">inventory/publisher/sales.go (0.0%)</option>
				
				<option value="file22">inventory/repository/product/product_impl.go (100.0%)</option>
				
				<option value="file23">inventory/repository/purchase/purchase_impl.go (100.0%)</option>
				
				<option value="file24">inventory/repository/sales/sales_impl.go (100.0%)</option>
				
				<option value="file25">inventory/service/product_impl.go (100.0%)</option>
				
				<option value="file26">inventory/service/purchase_impl.go (100.0%)</option>
				
				<option value="file27">inventory/service/sales_impl.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"

        "github.com/spf13/viper"
)

type Config struct {
        JsonPort string `mapstructure:"json_port"`

        DbUsername string `mapstructure:"db_username"`
        DbPassword string `mapstructure:"db_password"`
        DbHost     string `mapstructure:"db_host"`
        DbPort     string `mapstructure:"db_port"`
        DbName     string `mapstructure:"db_name"`
        DbMain     string `mapstructure:"db_main"`
}

func LoadConfig() *Config <span class="cov0" title="0">{
        viper.SetConfigFile(".env")
        err := viper.ReadInConfig()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("fatal error config file: %s", err))</span>
        }
        <span class="cov0" title="0">config := Config{}
        err = viper.Unmarshal(&amp;config)
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("fatal error decode file: %s", err))</span>
        }

        <span class="cov0" title="0">return &amp;config</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "inventory/helper"
        "inventory/helper/middleware"
        "inventory/model"
        "inventory/service"
        "net/http"

        "github.com/gin-gonic/gin"
)

type handlerHttp struct {
        product  service.ProductService
        purchase service.PurchaseService
        sales    service.SalesService
}

func NewHandlerHttp(productService service.ProductService, purchaseService service.PurchaseService, salesService service.SalesService) InventoryHandlerHttp <span class="cov8" title="1">{
        return &amp;handlerHttp{
                product:  productService,
                purchase: purchaseService,
                sales:    salesService,
        }
}</span>

func (handler *handlerHttp) Authentication(c *gin.Context) <span class="cov0" title="0">{

        keyss := c.GetHeader("key")

        err := helper.ComparePassword(keyss, "phincon")
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, map[string]string{
                        "message": "Gagal",
                })
        }</span> else<span class="cov0" title="0"> {
                c.JSON(http.StatusOK, map[string]string{
                        "message": "Berhasil",
                })
        }</span>

}

// product
func (handler *handlerHttp) ProductShow(c *gin.Context) <span class="cov8" title="1">{
        result, _ := handler.product.ShowProduct()
        c.JSON(result.Status, result)
}</span>

// purchase
func (handler *handlerHttp) PurchaseInput(c *gin.Context) <span class="cov0" title="0">{
        var data []model.ReqPurchase

        err := c.ShouldBindJSON(&amp;data)
        middleware.FailError(err, "baris satu")

        result, _ := handler.purchase.InputPurchase(data)

        c.JSON(result.Status, result)
}</span>

func (handler *handlerHttp) PurchaseDetail(c *gin.Context) <span class="cov0" title="0">{
        order := c.Param("order")

        result, _ := handler.purchase.DetailPurchase(order)
        c.JSON(result.Status, result)
}</span>

// sales
func (handler *handlerHttp) SalesInput(c *gin.Context) <span class="cov0" title="0">{
        var data []model.ReqSales

        err := c.ShouldBindJSON(&amp;data)
        middleware.FailError(err, "baris satu")

        result, _ := handler.sales.InputSales(data)

        c.JSON(result.Status, result)
}</span>

func (handler *handlerHttp) SalesDetail(c *gin.Context) <span class="cov0" title="0">{
        order := c.Param("order")

        result, _ := handler.sales.DetailSales(order)
        c.JSON(result.Status, result)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package db

import (
        _ "github.com/jackc/pgx/v5/stdlib"
        _ "github.com/lib/pq"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func GetConnection() *gorm.DB <span class="cov0" title="0">{
        // config := config.LoadConfig()

        dsn := "host=localhost user=postgres password=admin dbname=go-inventory port=5432 sslmode=disable TimeZone=Asia/Jakarta"
        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return db</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package helper

import (
        "golang.org/x/crypto/bcrypt"
)

func ComparePassword(hashedPassword string, password string) (err error) <span class="cov0" title="0">{
        return bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package helper

import (
        "os"
        "os/exec"
        "runtime"
)

func CallClear() <span class="cov0" title="0">{
        clear := make(map[string]func()) //Initialize it
        clear["linux"] = func() </span><span class="cov0" title="0">{
                cmd := exec.Command("clear") //Linux example, its tested
                cmd.Stdout = os.Stdout
                cmd.Run()
        }</span>
        <span class="cov0" title="0">clear["windows"] = func() </span><span class="cov0" title="0">{
                cmd := exec.Command("cmd", "/c", "cls") //Windows example, its tested
                cmd.Stdout = os.Stdout
                cmd.Run()
        }</span>

        <span class="cov0" title="0">value, ok := clear[runtime.GOOS] //runtime.GOOS -&gt; linux, windows, darwin etc.
        if ok </span><span class="cov0" title="0">{                          //if we defined a clear func for that platform:
                value() //we execute it
        }</span> else<span class="cov0" title="0"> { //unsupported platform
                panic("Your platform is unsupported! I can't clear terminal screen :(")</span>
        }
}

func RedirectBack() {<span class="cov0" title="0">

}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package middleware

import (
        "context"
        "encoding/json"
        "io"
        "log"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

func CheckAuth() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{

                if c.Request.Header.Get("auth") == "1221" </span><span class="cov0" title="0">{
                        c.Next()
                }</span> else<span class="cov0" title="0"> {
                        c.Abort()
                        c.Redirect(http.StatusMovedPermanently, "/auth")
                }</span>
        }

}

func HeaderVerificationMiddleware(ginCtx *gin.Context) <span class="cov0" title="0">{
        hashKeyStr := ginCtx.GetHeader("key")

        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, "http://localhost:5000/auth", nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error 1")
                ginCtx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">req.Header.Add("key", hashKeyStr)

        res, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("error 2")
                ginCtx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()

        body, err := io.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                ginCtx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var response map[string]interface{}
        err = json.Unmarshal(body, &amp;response)
        if err != nil </span><span class="cov0" title="0">{
                ginCtx.AbortWithStatus(http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if response["message"] == "Gagal" </span><span class="cov0" title="0">{
                ginCtx.AbortWithStatus(http.StatusUnauthorized)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package middleware

import "log"

func FailError(err error, msg string) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                log.Panicf("%s : %s", err, msg)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "time"

        "github.com/gin-gonic/gin"
        "github.com/rs/zerolog/log"
)

func Logger() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Create a logger instance for the request
                logger := log.With().
                        Str("requestId", c.Request.Header.Get("X-Request-ID")).
                        Logger()

                // Log the request information
                logger.Info().
                        Str("method", c.Request.Method).
                        Str("path", c.Request.URL.Path).
                        Str("ip", c.ClientIP()).
                        Msg("Incoming request")

                // Proceed with the request handling
                c.Next()
                // Log the response information
                logger.Info().
                        Int("statusCode", c.Writer.Status()).
                        Dur("responseTime", time.Since(start)).
                        Msg("Outgoing response")

        }</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package helper

import (
        "math/rand"
        "time"
)

type RandomInterface interface {
        Randomizer() string
}

type random struct {
}

func NewRandom() *random <span class="cov0" title="0">{
        return &amp;random{}
}</span>

func (r *random) Randomizer() string <span class="cov0" title="0">{
        time.Sleep(1 * time.Second)
        randomizer := rand.New(rand.NewSource(time.Now().Unix()))

        letters := []rune("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

        b := make([]rune, 7)

        for i := range b </span><span class="cov0" title="0">{
                b[i] = letters[randomizer.Intn(len(letters))]
        }</span>
        <span class="cov0" title="0">rand := string(b)
        return rand</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package main

import (
        "inventory/controller"
        "inventory/db"
        "inventory/helper"
        "inventory/helper/middleware"
        "inventory/publisher"
        "inventory/repository/product"
        "inventory/repository/purchase"
        "inventory/repository/sales"
        "inventory/service"

        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{

        db := db.GetConnection()
        random := helper.NewRandom()
        publishPurchase := publisher.Newpurchase()
        publishSales := publisher.NewSales()

        repoProduct := product.NewProductRepository(db)
        repoPurchase := purchase.NewPurchaseRepository(db, publishPurchase, random)
        repoSales := sales.NewSalesRepository(db, publishSales, random)

        purchase := service.NewPurchaseService(repoPurchase)
        product := service.NewProductService(repoProduct)
        sales := service.NewSalesService(repoSales)

        Inventory := controller.NewHandlerHttp(product, purchase, sales)
        NewServer(Inventory)
        // consumer.ConPurchase()
}</span>

func NewServer(controller controller.InventoryHandlerHttp) <span class="cov0" title="0">{
        // server
        // r := gin.Default()
        r := gin.New()

        // middleware
        r.Use(middleware.Logger())

        r1 := r.Group("/inven", middleware.HeaderVerificationMiddleware)
        // routes
        r1.GET("/product", controller.ProductShow)
        r1.POST("/purchase", controller.PurchaseInput)
        r1.GET("/purchase/:order", controller.PurchaseDetail)
        r1.POST("/sales", controller.SalesInput)
        r1.GET("/sales/:order", controller.SalesDetail)

        r.GET("/auth", controller.Authentication)

        r.Run(":5000")
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package mocks

import (
        "github.com/stretchr/testify/mock"
)

type ControllerMock struct {
        mock.Mock
}

func NewControllerMock() *ControllerMock <span class="cov0" title="0">{
        return &amp;ControllerMock{}
}</span>

func (m *ControllerMock) ComparePassword(hashedPassword string, password string) (err error) <span class="cov0" title="0">{
        ret := m.Called(hashedPassword, password)
        err = ret.Error(0)
        return err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package mocks

import (
        "inventory/model"

        "github.com/stretchr/testify/mock"
)

type ProductControllerMock struct {
        mock.Mock
}

func NewProductControllerMock() *ProductControllerMock <span class="cov8" title="1">{
        return &amp;ProductControllerMock{}
}</span>

func (m ProductControllerMock) ShowProduct() (model.InventoryResponse, error) <span class="cov8" title="1">{
        ret := m.Called()
        res := ret.Get(0).(model.InventoryResponse)
        err := ret.Error(1)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package mocks

import (
        "inventory/model"

        "github.com/stretchr/testify/mock"
)

type ServProductMock struct {
        mock.Mock
}

func NewServProductMock() *ServProductMock <span class="cov8" title="1">{
        return &amp;ServProductMock{}
}</span>

func (m *ServProductMock) ShowProduct() ([]model.Product, error) <span class="cov8" title="1">{
        ret := m.Called()
        result := ret.Get(0).([]model.Product)
        err := ret.Error(1)
        return result, err
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package mocks

import (
        "inventory/model"

        "github.com/stretchr/testify/mock"
)

type PurchaseControllerMock struct {
        mock.Mock
}

func NewPurchaseControllerMock() *PurchaseControllerMock <span class="cov8" title="1">{
        return &amp;PurchaseControllerMock{}
}</span>

func (m *PurchaseControllerMock) InputPurchase(req []model.ReqPurchase) (model.InventoryResponse, error) <span class="cov0" title="0">{
        ret := m.Called(req)
        res := ret.Get(0).(model.InventoryResponse)
        err := ret.Error(1)
        return res, err
}</span>

func (m *PurchaseControllerMock) DetailPurchase(req string) (model.InventoryResponse, error) <span class="cov0" title="0">{
        ret := m.Called(req)
        res := ret.Get(0).(model.InventoryResponse)
        err := ret.Error(1)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package mocks

import "github.com/stretchr/testify/mock"

type PurchaseMock struct {
        mock.Mock
}

func NewPublisher() *PurchaseMock <span class="cov8" title="1">{
        return &amp;PurchaseMock{}
}</span>

func (m *PurchaseMock) PubPurchase(body interface{}) (err error) <span class="cov8" title="1">{
        // sebagai indikator parameter diperoleh
        ret := m.Called(body)
        err = ret.Error(0)
        return
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package mocks

import (
        "inventory/model"

        "github.com/stretchr/testify/mock"
)

type ServPurchaseMock struct {
        mock.Mock
}

func NewServPurchaseMock() *ServPurchaseMock <span class="cov8" title="1">{
        return &amp;ServPurchaseMock{}
}</span>

func (m *ServPurchaseMock) InputPurchase(req []model.ReqPurchase) ([]model.PurchaseDetail, error) <span class="cov8" title="1">{
        ret := m.Called(req)
        result := ret.Get(0).([]model.PurchaseDetail)
        err := ret.Error(1)
        return result, err
}</span>

func (m *ServPurchaseMock) DetailPurchase(req string) (model.PurchaseDetail, error) <span class="cov8" title="1">{
        ret := m.Called(req)
        result := ret.Get(0).(model.PurchaseDetail)
        err := ret.Error(1)
        return result, err
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package mocks

import "github.com/stretchr/testify/mock"

type RandomMock struct {
        mock.Mock
}

func NewRandom() *RandomMock <span class="cov8" title="1">{
        return &amp;RandomMock{}
}</span>

func (m *RandomMock) Randomizer() string <span class="cov8" title="1">{
        ret := m.Called()
        randomNumber := ret.Get(0).(string)
        return randomNumber
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package mocks

import (
        "inventory/model"

        "github.com/stretchr/testify/mock"
)

type SalesControllerMock struct {
        mock.Mock
}

func NewSalesControllerMock() *SalesControllerMock <span class="cov8" title="1">{
        return &amp;SalesControllerMock{}
}</span>

func (m *SalesControllerMock) InputSales(req []model.ReqSales) (model.InventoryResponse, error) <span class="cov0" title="0">{
        ret := m.Called(req)
        res := ret.Get(0).(model.InventoryResponse)
        err := ret.Error(1)
        return res, err
}</span>

func (m *SalesControllerMock) DetailSales(req string) (model.InventoryResponse, error) <span class="cov0" title="0">{
        ret := m.Called(req)
        res := ret.Get(0).(model.InventoryResponse)
        err := ret.Error(1)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package mocks

import "github.com/stretchr/testify/mock"

type SalesMock struct {
        mock.Mock
}

func NewSales() *SalesMock <span class="cov8" title="1">{
        return &amp;SalesMock{}
}</span>

func (m *SalesMock) PubSales(body interface{}) (err error) <span class="cov8" title="1">{
        // sebagai indikator parameter diperoleh
        ret := m.Called(body)
        err = ret.Error(0)
        return
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package mocks

import (
        "inventory/model"

        "github.com/stretchr/testify/mock"
)

type servSalesMock struct {
        mock.Mock
}

func NewServSalesMock() *servSalesMock <span class="cov8" title="1">{
        return &amp;servSalesMock{}
}</span>

func (m *servSalesMock) InputSales(req []model.ReqSales) ([]model.SalesDetail, error) <span class="cov8" title="1">{
        ret := m.Called(req)
        res := ret.Get(0).([]model.SalesDetail)
        err := ret.Error(1)
        return res, err
}</span>

func (m *servSalesMock) DetailSales(req string) (model.SalesDetail, error) <span class="cov8" title="1">{
        ret := m.Called(req)
        res := ret.Get(0).(model.SalesDetail)
        err := ret.Error(1)
        return res, err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package publisher

import (
        "context"
        "encoding/json"
        "inventory/helper/middleware"
        "log"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

type purchase struct {
}

func Newpurchase() *purchase <span class="cov0" title="0">{
        return &amp;purchase{}
}</span>

type PurchaseInterface interface {
        PubPurchase(body interface{}) error
}

func (p *purchase) PubPurchase(data interface{}) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
        middleware.FailError(err, "Failed to connect to RabbitMQ")
        defer conn.Close()

        // membuat channel
        ch, err := conn.Channel()
        middleware.FailError(err, "Failed to open a channel")
        defer ch.Close()

        // membuat queue
        q, err := ch.QueueDeclare(
                "Purchase1", // name
                false,       // durable
                false,       // delete when unused
                false,       // exclusive
                false,       // no-wait
                nil,         // arguments
        )
        middleware.FailError(err, "Failed to declare a queue")

        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = ch.PublishWithContext(
                ctx,    // context
                "",     // exchange
                q.Name, // routing key
                false,  // mandatory
                false,  // immediate
                amqp.Publishing{
                        ContentType: "text/plain",
                        Body:        body,
                })
        middleware.FailError(err, "Failed to publish a message")
        log.Printf(" [x] Sent")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package publisher

import (
        "context"
        "encoding/json"
        "inventory/helper/middleware"
        "log"
        "time"

        amqp "github.com/rabbitmq/amqp091-go"
)

type sales struct {
}

func NewSales() *sales <span class="cov0" title="0">{
        return &amp;sales{}
}</span>

type SalesInterface interface {
        PubSales(body interface{}) error
}

func (r *sales) PubSales(data interface{}) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
        middleware.FailError(err, "Failed to connect to RabbitMQ")
        defer conn.Close()

        // membuat channel
        ch, err := conn.Channel()
        middleware.FailError(err, "Failed to open a channel")
        defer ch.Close()

        // membuat queue
        q, err := ch.QueueDeclare(
                "Sales1", // name
                false,    // durable
                false,    // delete when unused
                false,    // exclusive
                false,    // no-wait
                nil,      // arguments
        )
        middleware.FailError(err, "Failed to declare a queue")

        body, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err = ch.PublishWithContext(
                ctx,    // context
                "",     // exchange
                q.Name, // routing key
                false,  // mandatory
                false,  // immediate
                amqp.Publishing{
                        ContentType: "text/plain",
                        Body:        body,
                })
        middleware.FailError(err, "Failed to publish a message")
        log.Printf(" [x] Sent")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package product

import (
        "errors"
        "inventory/model"

        "gorm.io/gorm"
)

type productRepository struct {
        db *gorm.DB
}

func NewProductRepository(dbs *gorm.DB) ProductRepository <span class="cov8" title="1">{
        return &amp;productRepository{
                db: dbs,
        }
}</span>

func (repo *productRepository) ShowProduct() ([]model.Product, error) <span class="cov8" title="1">{
        var productrepo []model.Product

        query := "SELECT * FROM products"

        repo.db.Raw(query).Scan(&amp;productrepo)

        if productrepo == nil </span><span class="cov8" title="1">{
                return productrepo, errors.New("")
        }</span>

        <span class="cov8" title="1">return productrepo, nil</span>

}
</pre>
		
		<pre class="file" id="file23" style="display: none">package purchase

import (
        "errors"
        "inventory/helper"
        "inventory/helper/middleware"
        "inventory/model"
        "inventory/publisher"
        "log"
        "time"

        "gorm.io/gorm"
)

type purchaseRepository struct {
        db        *gorm.DB
        publisher publisher.PurchaseInterface
        random    helper.RandomInterface
}

func NewPurchaseRepository(dbs *gorm.DB, publish publisher.PurchaseInterface, randoms helper.RandomInterface) PurchaseRepository <span class="cov8" title="1">{
        return &amp;purchaseRepository{
                db:        dbs,
                publisher: publish,
                random:    randoms,
        }
}</span>

func (r *purchaseRepository) InputPurchase(req []model.ReqPurchase) ([]model.PurchaseDetail, error) <span class="cov8" title="1">{
        var send []model.SendPurchase
        var returns []model.PurchaseDetail

        for _, v := range req </span><span class="cov8" title="1">{
                if v.Total &lt;= 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">sending := model.SendPurchase{
                        Item:        v.Item,
                        Price:       v.Price,
                        From:        v.From,
                        Total:       v.Total,
                        OrderNumber: r.random.Randomizer(),
                }
                send = append(send, sending)</span>
        }

        <span class="cov8" title="1">r.publisher.PubPurchase(send)

        // get return

        time.Sleep(1 * time.Second)

        selectPurchaseDetail := `select * from purchase p join purchase_detail pd on p.id = pd.purchase_id where order_number = $1`
        for _, d := range send </span><span class="cov8" title="1">{
                var returnP model.PurchaseReturn
                r.db.Raw(selectPurchaseDetail, d.OrderNumber).Scan(&amp;returnP)

                resultDetail := model.PurchaseDetail{
                        Id:          returnP.Id,
                        Purchase_id: returnP.Purchase_id,
                        Item:        returnP.Item,
                        Price:       returnP.Price,
                        Quantity:    returnP.Quantity,
                        Total:       returnP.Total,
                        Purchase: model.Purchase{
                                Id:          returnP.Purchase_id,
                                OrderNumber: returnP.OrderNumber,
                                From:        returnP.From,
                                Total:       returnP.Quantity,
                        },
                }
                returns = append(returns, resultDetail)
        }</span>
        // Commit the transaction

        <span class="cov8" title="1">return returns, nil</span>
}

func (r *purchaseRepository) DetailPurchase(req string) (model.PurchaseDetail, error) <span class="cov8" title="1">{
        log.Println(req)

        var returnP model.PurchaseReturn
        var idOrder uint
        var err error

        checkOrder := `select id from purchase where order_number = $1`
        selectPurchaseDetail := `select * from purchase p join purchase_detail pd on p.id = pd.purchase_id where order_number = $1`

        err = r.db.Raw(checkOrder, req).Scan(&amp;idOrder).Error
        middleware.FailError(err, "")

        if idOrder == 0 </span><span class="cov8" title="1">{
                return model.PurchaseDetail{}, errors.New("order tidak ditemukan")
        }</span>

        <span class="cov8" title="1">err = r.db.Raw(selectPurchaseDetail, req).Scan(&amp;returnP).Error
        middleware.FailError(err, "")

        resultDetail := model.PurchaseDetail{
                Id:          returnP.Id,
                Purchase_id: returnP.Purchase_id,
                Item:        returnP.Item,
                Price:       returnP.Price,
                Quantity:    returnP.Quantity,
                Total:       returnP.Total,
                Purchase: model.Purchase{
                        Id:          returnP.Purchase_id,
                        OrderNumber: returnP.OrderNumber,
                        From:        returnP.From,
                        Total:       returnP.Quantity,
                },
        }

        return resultDetail, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package sales

import (
        "errors"
        "inventory/helper"
        "inventory/helper/middleware"
        "inventory/model"
        "inventory/publisher"
        "time"

        "gorm.io/gorm"
)

type salesRepository struct {
        db        *gorm.DB
        publisher publisher.SalesInterface
        random    helper.RandomInterface
}

func NewSalesRepository(dbs *gorm.DB, publish publisher.SalesInterface, randoms helper.RandomInterface) SalesRepository <span class="cov8" title="1">{
        return &amp;salesRepository{
                db:        dbs,
                publisher: publish,
                random:    randoms,
        }
}</span>

func (r *salesRepository) InputSales(req []model.ReqSales) ([]model.SalesDetail, error) <span class="cov8" title="1">{

        var send []model.SendSales
        var returns []model.SalesDetail

        for _, v := range req </span><span class="cov8" title="1">{
                if v.Total &lt;= 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">sending := model.SendSales{
                        Item:        v.Item,
                        Price:       v.Price,
                        From:        v.From,
                        Total:       v.Total,
                        OrderNumber: r.random.Randomizer(),
                }
                send = append(send, sending)</span>
        }

        <span class="cov8" title="1">r.publisher.PubSales(send)

        // get return
        time.Sleep(1 * time.Second)

        selectSalesDetail := `select * from sales p join sales_detail pd on p.id = pd.sales_id where order_number = $1`

        for _, d := range send </span><span class="cov8" title="1">{
                var returnP model.SalesReturn
                r.db.Raw(selectSalesDetail, d.OrderNumber).Scan(&amp;returnP)

                // if returnP.Id == 0 {
                //         continue
                // }

                resultDetail := model.SalesDetail{
                        Id:       returnP.Id,
                        Sales_id: returnP.Sales_id,
                        Item:     returnP.Item,
                        Price:    returnP.Price,
                        Quantity: returnP.Quantity,
                        Total:    returnP.Total,
                        Sales: model.Sales{
                                Id:          returnP.Sales_id,
                                OrderNumber: returnP.OrderNumber,
                                From:        returnP.From,
                                Total:       returnP.Quantity,
                        },
                }
                returns = append(returns, resultDetail)
        }</span>

        <span class="cov8" title="1">if returns == nil </span><span class="cov8" title="1">{
                return returns, errors.New("error")
        }</span>

        <span class="cov8" title="1">return returns, nil</span>
}

func (r *salesRepository) DetailSales(req string) (model.SalesDetail, error) <span class="cov8" title="1">{
        var returnP model.SalesReturn
        var idOrder uint
        var err error

        checkOrder := `select id from sales where order_number = $1`
        selectsalesDetail := `select * from sales p join sales_detail pd on p.id = pd.sales_id where order_number = $1`

        err = r.db.Raw(checkOrder, req).Scan(&amp;idOrder).Error
        middleware.FailError(err, "")

        if idOrder == 0 </span><span class="cov8" title="1">{
                return model.SalesDetail{}, errors.New("order tidak ditemukan")
        }</span>

        <span class="cov8" title="1">err = r.db.Raw(selectsalesDetail, req).Scan(&amp;returnP).Error
        middleware.FailError(err, "")

        resultDetail := model.SalesDetail{
                Id:       returnP.Id,
                Sales_id: returnP.Sales_id,
                Item:     returnP.Item,
                Price:    returnP.Price,
                Quantity: returnP.Quantity,
                Total:    returnP.Total,
                Sales: model.Sales{
                        Id:          returnP.Sales_id,
                        OrderNumber: returnP.OrderNumber,
                        From:        returnP.From,
                        Total:       returnP.Quantity,
                },
        }

        return resultDetail, nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package service

import (
        "inventory/model"
        "inventory/repository/product"
        "net/http"
)

type productService struct {
        repository product.ProductRepository
}

func NewProductService(repo product.ProductRepository) ProductService <span class="cov8" title="1">{
        return &amp;productService{
                repository: repo,
        }
}</span>

func (service *productService) ShowProduct() (model.InventoryResponse, error) <span class="cov8" title="1">{
        data, err := service.repository.ShowProduct()
        if err != nil </span><span class="cov8" title="1">{
                return model.InventoryResponse{
                        Status:  http.StatusBadGateway,
                        Message: "Bad Gateway",
                        Data:    nil,
                }, err
        }</span> else<span class="cov8" title="1"> {
                return model.InventoryResponse{
                        Status:  http.StatusOK,
                        Message: "OK",
                        Data:    data,
                }, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "inventory/model"
        "inventory/repository/purchase"
        "net/http"
)

type purchaseService struct {
        repository purchase.PurchaseRepository
}

func NewPurchaseService(repo purchase.PurchaseRepository) PurchaseService <span class="cov8" title="1">{
        return &amp;purchaseService{
                repository: repo,
        }
}</span>

func (s *purchaseService) InputPurchase(req []model.ReqPurchase) (model.InventoryResponse, error) <span class="cov8" title="1">{
        data, err := s.repository.InputPurchase(req)
        if err != nil </span><span class="cov8" title="1">{
                return model.InventoryResponse{
                        Status:  http.StatusBadRequest,
                        Message: "Bad Request",
                        Data:    nil,
                }, err
        }</span> else<span class="cov8" title="1"> {
                return model.InventoryResponse{
                        Status:  http.StatusOK,
                        Message: "OK",
                        Data:    data,
                }, nil
        }</span>
}

func (s *purchaseService) DetailPurchase(req string) (model.InventoryResponse, error) <span class="cov8" title="1">{
        data, err := s.repository.DetailPurchase(req)
        if err != nil </span><span class="cov8" title="1">{
                return model.InventoryResponse{
                        Status:  http.StatusBadRequest,
                        Message: "Bad Request",
                        Data:    nil,
                }, err
        }</span> else<span class="cov8" title="1"> {
                return model.InventoryResponse{
                        Status:  http.StatusOK,
                        Message: "OK",
                        Data:    data,
                }, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package service

import (
        "inventory/model"
        "inventory/repository/sales"
        "net/http"
)

type salesService struct {
        repository sales.SalesRepository
}

func NewSalesService(repo sales.SalesRepository) SalesService <span class="cov8" title="1">{
        return &amp;salesService{
                repository: repo,
        }
}</span>

func (s *salesService) InputSales(req []model.ReqSales) (model.InventoryResponse, error) <span class="cov8" title="1">{
        data, err := s.repository.InputSales(req)
        if err != nil </span><span class="cov8" title="1">{
                return model.InventoryResponse{
                        Status:  http.StatusBadRequest,
                        Message: "Bad Request",
                        Data:    nil,
                }, err
        }</span> else<span class="cov8" title="1"> {
                return model.InventoryResponse{
                        Status:  http.StatusOK,
                        Message: "OK",
                        Data:    data,
                }, nil
        }</span>
}

func (s *salesService) DetailSales(req string) (model.InventoryResponse, error) <span class="cov8" title="1">{
        data, err := s.repository.DetailSales(req)
        if err != nil </span><span class="cov8" title="1">{
                return model.InventoryResponse{
                        Status:  http.StatusBadRequest,
                        Message: "Bad Request",
                        Data:    nil,
                }, err
        }</span> else<span class="cov8" title="1"> {
                return model.InventoryResponse{
                        Status:  http.StatusOK,
                        Message: "OK",
                        Data:    data,
                }, nil
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
